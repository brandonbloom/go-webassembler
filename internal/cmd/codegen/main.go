package main

import (
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
)

// Instruction represents a WebAssembly instruction from the CSV file
type Instruction struct {
	Opcode    []string
	Signature string
	Method    string
	Params    []Param
	ParamList string
}

type Param struct {
	Name string
	Type string
}

const instructionTemplate = `
// {{ .Signature }}
func (c *Code) {{ .Method }}({{ .ParamList }}) {
	{{- range .Opcode }}
	c.buf.WriteRawByte(0x{{ . }})
	{{- end }}
	{{- range .Params }}
	c.buf.Write{{ .Type }}({{ .Name }})
	{{- end }}
}
`

func main() {
	// Parse the CSV from stdin
	reader := csv.NewReader(os.Stdin)
	records, err := reader.ReadAll()
	if err != nil {
		log.Fatalf("Failed to read CSV: %v", err)
	}

	// Write header to stdout
	fmt.Println(`// Code generated by internal/cmd/codegen/main.go; DO NOT EDIT.

package webassembler

// Writer methods for WebAssembly instructions`)

	// Create template
	tmpl, err := template.New("instruction").Parse(instructionTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	// Process records and generate code
	for i, record := range records {
		// Skip header row
		if i == 0 {
			continue
		}

		// Get fields from CSV
		name := record[0]
		immediates := record[1]
		opcode := record[2]
		input := record[3]
		output := record[4]

		// Skip empty or incomplete rows
		if name == "" || opcode == "" {
			continue
		}

		// Parse.
		params := parseParams(immediates)
		effect := formatStackEffect(input, output)

		// Create instruction object
		instr := Instruction{
			Opcode:    strings.Split(opcode, " "),
			Method:    formatMethodName(name),
			Signature: formatSignature(name, immediates, effect),
			Params:    params,
			ParamList: formatParamList(params),
		}

		// Execute template to stdout
		err = tmpl.Execute(os.Stdout, instr)
		if err != nil {
			log.Fatalf("Failed to execute template for %s: %v", name, err)
		}
	}

}

func formatMethodName(instruction string) string {
	instruction = strings.ReplaceAll(instruction, ".", "._")
	parts := strings.Split(instruction, "_")
	method := ""
	for _, part := range parts {
		method += strings.ToUpper(string(part[0]))
		method += string(part[1:])
	}
	return strings.ReplaceAll(method, ".", "_")
}

func formatStackEffect(input string, output string) string {
	effect := "( "
	if len(input) > 0 {
		effect += input + " "
	}
	effect += "--"
	if len(output) > 0 {
		effect += " " + output
	}
	effect += " )"
	return strings.ReplaceAll(effect, ".", "_")
}

func formatSignature(name string, immediates string, effect string) string {
	signature := name
	if len(immediates) > 0 {
		signature += " " + immediates
	}
	if len(effect) > 0 {
		signature += " " + effect
	}
	return signature
}

func parseParams(immediates string) []Param {
	if immediates == "" {
		return nil
	}
	imms := strings.Split(immediates, " ")
	params := make([]Param, len(imms))
	for i, imm := range imms {
		params[i] = parseParam(i, imm)
	}
	return params
}

func parseParam(i int, imm string) Param {
	switch imm {
	case "memarg":
		return Param{"mem", "MemArg"}
	case "i32":
		return Param{"val", "I32"}
	case "i64":
		return Param{"val", "I64"}
	case "f32":
		return Param{"val", "F32"}
	case "f64":
		return Param{"val", "F64"}
	case "i128":
		return Param{"val", "I128"}
	case "laneidx":
		return Param{"lane", "LaneIdx"}
	case "laneidx{16}":
		return Param{"lanes", "LaneShuffle"}
	case "l":
		return Param{fmt.Sprintf("label%d", i), "LabelIdx"}
	case "bt":
		return Param{"blockType", "TypeIdx"}
	case "x":
		return Param{"idx", "U32"} // XXX what type of index?
	case "y":
		return Param{"idx2", "U32"} // XXX what type of index?
	case "t":
		return Param{"typ", "TypeIdx"}
	case "local":
		return Param{"x", "LocalIdx"}
	case "global":
		return Param{"x", "GlobalIdx"}
	default:
		return Param{fmt.Sprintf("arg%d", i), fmt.Sprintf("Invalid[%s]", imm)}
	}
}

func formatParamList(params []Param) string {
	var sb strings.Builder
	sep := ""
	for _, param := range params {
		sb.WriteString(sep)
		sep = ", "
		sb.WriteString(param.Name)
		sb.WriteString(" ")
		sb.WriteString(param.Type)
	}
	return sb.String()
}
